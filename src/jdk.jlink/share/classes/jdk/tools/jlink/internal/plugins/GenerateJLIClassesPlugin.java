/*
 * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.  Oracle designates this
 * particular file as subject to the "Classpath" exception as provided
 * by Oracle in the LICENSE file that accompanied this code.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */
package jdk.tools.jlink.internal.plugins;

import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.UncheckedIOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.EnumSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import jdk.internal.access.JavaLangInvokeAccess;
import jdk.internal.access.SharedSecrets;
import jdk.tools.jlink.internal.ExecutableImage;
import jdk.tools.jlink.internal.ImagePluginStack.ImageProvider;
import jdk.tools.jlink.internal.PostProcessor;
import jdk.tools.jlink.plugin.PluginException;
import jdk.tools.jlink.plugin.ResourcePool;
import jdk.tools.jlink.plugin.ResourcePoolBuilder;
import jdk.tools.jlink.plugin.ResourcePoolEntry;

/**
 * Plugin to generate java.lang.invoke classes.
 *
 * The plugin reads in a file generated by running any application with
 * {@code -Djava.lang.invoke.MethodHandle.TRACE_RESOLVE=true}. This is done
 * automatically during build, see make/GenerateLinkOptData.gmk. See
 * build/tools/classlist/HelloClasslist.java for the training application.
 *
 * HelloClasslist tries to reflect common use of java.lang.invoke during early
 * startup and warmup in various applications. To ensure a good default
 * trade-off between static footprint and startup the application should be
 * relatively conservative.
 *
 * When using jlink to build a custom application runtime, generating a trace
 * file using {@code -Djava.lang.invoke.MethodHandle.TRACE_RESOLVE=true} and
 * feeding that into jlink using {@code --generate-jli-classes=@trace_file} can
 * help improve startup time.
 */
public final class GenerateJLIClassesPlugin extends AbstractPlugin implements PostProcessor {


    private static final String DEFAULT_TRACE_FILE = "default_jli_trace.txt";

    private static final JavaLangInvokeAccess JLIA
            = SharedSecrets.getJavaLangInvokeAccess();

    private String mainArgument;
    private Stream<String> traceFileStream;

    public GenerateJLIClassesPlugin() {
        super("generate-jli-classes");
        Thread.dumpStack();
    }

    private String javaExecutableName() {
        if (System.getProperty("os.name").toLowerCase().contains("win")) {
            return "java.exe";
        } else {
            return "java";
        }
    }

    private String archivePath(ExecutableImage image) {
        if (System.getProperty("os.name").toLowerCase().contains("win")) {
            return image.getHome().toString() + File.separator + "bin" + File.separator + "server";
        } else {
            return image.getHome().toString() + File.separator + "lib" + File.separator + "server";
        }
    }

    private void createCDSArchive(ExecutableImage image) {
        String[] javaCmdArray = new String[] {
            image.getHome().toString() + File.separator + "bin" + File.separator + javaExecutableName(),
            "-Xshare:dump",
        };
        List<String> javaCmd = Arrays.asList(javaCmdArray);
        System.out.println("command: " + javaCmd.stream().collect(
                                             Collectors.joining(" ")));
        ProcessBuilder builder = new ProcessBuilder(javaCmd);
        int status = -1;
        try {
            Process p = builder.start();
            status = p.waitFor();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        if (status == 0) {
            System.out.println("Created CDS archive successfully");
        } else {
            System.out.println("Failed creating CDS archive!");
        }
    }

    private void createNoCoopsCDSArchive(ExecutableImage image) {
        String archiveName = archivePath(image) + File.separator + "classes_nocoops.jsa";
        String[] javaCmdArray = new String[] {
            image.getHome().toString() + File.separator + "bin" + File.separator + javaExecutableName(),
            "-Xshare:dump",
            "-XX:-UseCompressedOops",
            "-XX:SharedArchiveFile=" + archiveName,
        };
        List<String> javaCmd = Arrays.asList(javaCmdArray);
        System.out.println("command: " + javaCmd.stream().collect(
                                             Collectors.joining(" ")));
        ProcessBuilder builder = new ProcessBuilder(javaCmd);
        int status = -1;
        try {
            Process p = builder.start();
            status = p.waitFor();
        } catch (Exception ex) {
            ex.printStackTrace();
        }
        if (status == 0) {
            System.out.println("Created NOCOOPS CDS archive successfully");
        } else {
            System.out.println("Failed creating NOCOOPS CDS archive!");
        }
    }

    @Override
    public List<String> process(ExecutableImage image, ImageProvider provider) {
        Thread.dumpStack();
        if (!provider.generateCDSArchive()) {
            System.out.println("    generateCDSArchive was not set");
            return null;
        }
        System.out.println("image.getHome() " + image.getHome().toString());
        Path classListPath = image.getHome().resolve("lib").resolve("classlist");
        File f = new File(classListPath.toString());
        if (f.exists()) {
            System.out.println("classListPath " + classListPath.toString());

            createCDSArchive(image);

            if (System.getProperty("os.arch").indexOf("64") != -1) {
                createNoCoopsCDSArchive(image);
            }
        }
        return null;
    }

    @Override
    public Set<State> getState() {
        return EnumSet.of(State.AUTO_ENABLED, State.FUNCTIONAL);
    }

    @Override
    public boolean hasArguments() {
        return true;
    }

    @Override
    public void configure(Map<String, String> config) {
        mainArgument = config.get(getName());
    }

    public void initialize(ResourcePool in) {
        // Load configuration from the contents in the supplied input file
        // - if none was supplied we look for the default file
        if (mainArgument == null || !mainArgument.startsWith("@")) {
            try (InputStream traceFile =
                    this.getClass().getResourceAsStream(DEFAULT_TRACE_FILE)) {
                if (traceFile != null) {
                    traceFileStream = new BufferedReader(new InputStreamReader(traceFile)).lines();
                }
            } catch (Exception e) {
                throw new PluginException("Couldn't read " + DEFAULT_TRACE_FILE, e);
            }
        } else {
            File file = new File(mainArgument.substring(1));
            if (file.exists()) {
                traceFileStream = fileLines(file);
            }
        }
    }

    private Stream<String> fileLines(File file) {
        try {
            return Files.lines(file.toPath());
        } catch (IOException io) {
            throw new PluginException("Couldn't read file");
        }
    }

    @Override
    public ResourcePool transform(ResourcePool in, ResourcePoolBuilder out) {
        initialize(in);
        // Copy all but DMH_ENTRY to out
        in.transformAndCopy(entry -> {
                // No trace file given.  Copy all entries.
                if (traceFileStream == null) return entry;

                // filter out placeholder entries
                String path = entry.path();
                if (path.equals(DIRECT_METHOD_HOLDER_ENTRY) ||
                    path.equals(DELEGATING_METHOD_HOLDER_ENTRY) ||
                    path.equals(INVOKERS_HOLDER_ENTRY) ||
                    path.equals(BASIC_FORMS_HOLDER_ENTRY)) {
                    return null;
                } else {
                    return entry;
                }
            }, out);

        // Generate Holder classes
        if (traceFileStream != null) {
            try {
                JLIA.generateHolderClasses(traceFileStream)
                    .forEach((cn, bytes) -> {
                        String entryName = "/java.base/" + cn + ".class";
                        ResourcePoolEntry ndata = ResourcePoolEntry.create(entryName, bytes);
                        out.add(ndata);
                    });
            } catch (Exception ex) {
                throw new PluginException(ex);
            }
        }
        return out.build();
    }

    private static final String DIRECT_METHOD_HOLDER_ENTRY =
            "/java.base/java/lang/invoke/DirectMethodHandle$Holder.class";
    private static final String DELEGATING_METHOD_HOLDER_ENTRY =
            "/java.base/java/lang/invoke/DelegatingMethodHandle$Holder.class";
    private static final String BASIC_FORMS_HOLDER_ENTRY =
            "/java.base/java/lang/invoke/LambdaForm$Holder.class";
    private static final String INVOKERS_HOLDER_ENTRY =
            "/java.base/java/lang/invoke/Invokers$Holder.class";
}
